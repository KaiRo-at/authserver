<?php
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */

class AuthUtils {
  // KaiRo.at authentication utilities PHP class
  // This class contains helper functions for the authentication system.
  //
  // function __construct($settings, $db)
  //   CONSTRUCTOR
  //   Settings are an associative array with a numeric pwd_cost field and an array pwd_nonces field.
  //   The DB is a PDO object.
  //
  // public $db
  //   A PDO database object for interaction.
  //
  // private $pwd_cost
  //   The cost parameter for use with PHP password_hash function.
  //
  // private $pwd_nonces
  //   The array of nonces to use for "peppering" passwords. For new hashes, the last one of those will be used.
  //     Generate a nonce with this command: |openssl rand -base64 48|
  //
  // function log($code, $additional_info)
  //   Log an entry for admin purposes, with a code and some additional info.
  //
  // function checkPasswordConstraints($new_password, $user_email)
  //   Check password constraints and return an array of error messages (empty if all constraints are met).
  //
  // function createSessionKey()
  //   Return a random session key.
  //
  // function createVerificationCode()
  //   Return a random acount/email verification code.
  //
  // function createTimeCode($session, [$offset], [$validity_minutes])
  //   Return a time-based code based on the key and ID of the given session.
  //     An offset can be given to create a specific code for verification, otherwise and offset will be generated.
  //     Also, an amount of minutes for the code to stay valid can be handed over, by default 10 minutes will be used.
  //
  // function verifyTimeCode($timecode_to_verify, $session, [$validity_minutes])
  //   Verify a given time-based code and return true if it's valid or false if it's not.
  //     See createTimeCode() documentation for the session and validity paramerters.
  //
  // function pwdHash($new_password)
  //   Return a hash for the given password.
  //
  // function pwdVerify($password_to_verify, $user)
  //   Return true if the password verifies against the pwdhash field of the user, false if not.
  //
  // function pwdNeedsRehash($user)
  //   Return true if the pwdhash field of the user uses an outdated standard and needs to be rehashed.

  function __construct($settings, $db) {
    // *** constructor ***
    $this->db = $db;
    if (array_key_exists('pwd_cost', $settings)) {
      $this->pwd_cost = $settings['pwd_cost'];
    }
    if (array_key_exists('pwd_nonces', $settings)) {
      $this->pwd_nonces = $settings['pwd_nonces'];
    }
  }

  public $db = null;
  private $pwd_cost = 10;
  private $pwd_nonces = array();

  function log($code, $info) {
    $result = $this->db->prepare('INSERT INTO `auth_log` (`code`, `info`, `ip_addr`) VALUES (:code, :info, :ipaddr);');
    if (!$result->execute(array(':code' => $code, ':info' => $info, ':ipaddr' => $_SERVER['REMOTE_ADDR']))) {
      // print($result->errorInfo()[2]);
    }
  }

  function checkPasswordConstraints($new_password, $user_email) {
    $errors = array();
    if ($new_password != trim($new_password)) {
      $errors[] = _('Password must not start or end with a whitespace character like a space.');
    }
    if (strlen($new_password) < 8) { $errors[] = sprintf(_('Password too short (min. %s characters).'), 8); }
    if (strlen($new_password) > 70) { $errors[] = sprintf(_('Password too long (max. %s characters).'), 70); }
    if ((strtolower($new_password) == strtolower($user_email)) ||
        in_array(strtolower($new_password), preg_split("/[@\.]+/", strtolower($user_email)))) {
      $errors[] = _('The passwort can not be equal to your email or any part of it.');
    }
    if ((strlen($new_password) < 15) && (preg_match('/^[a-zA-Z]+$/', $new_password))) {
      $errors[] = sprintf(_('Your password must use characters other than normal letters or contain least %s characters.'), 15);
    }
    if (preg_match('/^\d+$/', $new_password)) {
      $errors[] = sprintf(_('Your password cannot consist only of numbers.'), 15);
    }
    if (strlen(count_chars($new_password, 3)) < 5) {
      $errors[] = sprintf(_('Password does have to contain at least %s different characters.'), 5);
    }
    return $errors;
  }

  function createSessionKey() {
    return bin2hex(openssl_random_pseudo_bytes(512 / 8)); // Get 512 bits of randomness (128 byte hex string).
  }

  function createVerificationCode() {
    return bin2hex(openssl_random_pseudo_bytes(512 / 8)); // Get 512 bits of randomness (128 byte hex string).
  }

  function createTimeCode($session, $offset = null, $validity_minutes = 10) {
    // Matches TOTP algorithms, see https://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm
    $valid_seconds = intval($validity_minutes) * 60;
    if ($valid_seconds < 60) { $valid_seconds = 60; }
    $code_digits = 8;
    $time = time();
    $rest = is_null($offset)?($time % $valid_seconds):intval($offset); // T0, will be sent as part of code to make it valid for the full duration.
    $counter = floor(($time - $rest) / $valid_seconds);
    $hmac = mhash(MHASH_SHA1, $counter, $session['id'].$session['sesskey']);
    $offset = hexdec(substr(bin2hex(substr($hmac, -1)), -1)); // Get the last 4 bits as a number.
    $totp = hexdec(bin2hex(substr($hmac, $offset, 4))) & 0x7FFFFFFF; // Take 4 bytes at the offset, discard highest bit.
    $totp_value = sprintf('%0'.$code_digits.'d', substr($totp, -$code_digits));
    return $rest.'.'.$totp_value;
  }

  function verifyTimeCode($timecode_to_verify, $session, $validity_minutes = 10) {
    if (preg_match('/^(\d+)\.\d+$/', $timecode_to_verify, $regs)) {
      return ($timecode_to_verify === $this->createTimeCode($session, $regs[1], $validity_minutes));
    }
    return false;
  }

  function pwdHash($new_password) {
    $hash_prefix = '';
    if (count($this->pwd_nonces)) {
      $new_password .= $this->pwd_nonces[count($this->pwd_nonces) - 1];
      $hash_prefix = (count($this->pwd_nonces) - 1).'|';
    }
    return $hash_prefix.password_hash($new_password, PASSWORD_DEFAULT, array('cost' => $this->pwd_cost));
  }

  function pwdVerify($password_to_verify, $userdata) {
    $pwdhash = $userdata['pwdhash'];
    if (preg_match('/^(\d+)\|(.+)$/', $userdata['pwdhash'], $regs)) {
      $password_to_verify .= $this->pwd_nonces[$regs[1]];
      $pwdhash = $regs[2];
    }
    return password_verify($password_to_verify, $pwdhash);
  }

  function pwdNeedsRehash($userdata) {
    $nonceid = -1;
    $pwdhash = $userdata['pwdhash'];
    if (preg_match('/^(\d+)\|(.+)$/', $userdata['pwdhash'], $regs)) {
      $nonceid = $regs[1];
      $pwdhash = $regs[2];
    }
    if ($nonceid == count($this->pwd_nonces) - 1) {
      return password_needs_rehash($pwdhash, PASSWORD_DEFAULT, array('cost' => $this->pwd_cost));
    }
    else {
      return true;
    }
  }
}
?>
